# === Dependencies ===

# trash-cli # xclip

# === Config ===
#set hidden true
#set info size:atime
set drawbox true
set icons true
#set color256 true
set ignorecase true



# === Binding ===
 
# hjkl -> ctsr
map c updir # old h
map t down  # old j 
map s up    # old k  
map r open  # old l

# tsrl -> ***l 
map h # unmap
map j # unmap
map k # unmap
map l rename # old l
map kn :set sortby natural; set info
map ks :set sortby size; set info size
map kt :set sortby time; set info time
map ka :set sortby atime; set info atime
map kc :set sortby ctime; set info ctime
map ke :set sortby ext; set info

# others
map D trash 
map <c-c> clear
map ` mark-load
map m mark-save
map y # unmap
map yy :copy 

# custom commands binding
map ad push :mkdir<space>
map af push :touch<space>
map . :open-file-manager-window
map o push :open-with<space>
#map b show-selection
#map x push :yank-dirname<enter>
#map <c-p> push :yank-path<enter>
#map É push :yank-basename<enter>
#map é push :yank-basename-without-extension<enter>
map yp copy-path
map br batch-rename

# === Commands ====

# show selection
#cmd show-selection %echo "$fx" > ~/lf-test.txt
#cmd show-selection %echo "$fx" > ~/lf-test.txt
#cmd show-selection $printf "$fx" | sed 's/\r/" "/' > ~/lf-test.txt
#cmd show-selection $awk -v d="xx xx" '{s=(NR==1?s:s d)$0}END{print s}' "$fx" > ~/lf-test.txt
#cmd show-selection $printf "$fx" | tr -d '\r' "$fx" > ~/lf-test.txt
#cmd show-selection ${{
#    "$fx" | %sed s/\r/" "/ > ~/lf-test.txt
#}}

cmd show-selection ${{
    filesList=($printf '%s' "%fx")
    joinList=$(awk -v d="xx xx" '{s=(NR==1?s:s d)$0}END{print s}' $filesList)
    #echo $fx >> lf-result2.txt
    echo $filesList > lf-result.txt
    echo $joinList > lf-result2.txt
}}

# default program
cmd open ${{
        test -L "$f" && f=$(readlink -f "$f")
        if [[ "$(uname)" = "Linux" ]]; then
            case $(file --mime-type "$f" -b) in
                text/*) $EDITOR "$f";;
                application/pdf) xreader "$f";;
                *) for f in $fx; do xdg-open $f > /dev/null 2> /dev/null & done;;
            esac

        elif [[ "$(uname)" = "Darwin" ]]; then
            case $(file --mime-type "$f" -b) in
                text/*) open -a macvim "$f";;
                application/vnd.ms-excel|application/vnd.openxmlformats-officedocument.spreadsheetml.sheet) open -a "Microsoft Excel" "$f";;
                application/msword|application/vnd.openxmlformats-officedocument.wordprocessingml.document) open -a "Microsoft Word" "$f";;
                *) for f in $fx; do open $f > /dev/null 2> /dev/null & done;;
            esac
        fi
}}

# open with
#cmd open-with %"$@" $fx
cmd open-with %open -a "$@" "$fx"

#cmd open ${{
#    test -L "$f" && f=$(readlink -f "$f")
#    case $(file --mime-type "$f" -b) in
#        text/*) $EDITOR "$f";;
#        application/pdf) xreader "$f";;
#        *) for f in $fx; do xdg-open $f > /dev/null 2> /dev/null & done;;
#    esac
#}}

# move current file or selected files to trash folder
cmd trash ${{
     if [ -z "$fs" ]; then
        trash-put -v "$f" 
        #trash-put --trash-dir ~/.Trash "$f"
    else
        IFS="`printf '\n\t'`"; trash-put -v $fs
        #IFS="`printf '\n\t'`"; trash-put --trash-dir ~/.Trash  $fs
    fi
}}

# make directories
cmd mkdir ${{
    mkdir -p "$*"
}}

# create file
cmd touch ${{
    touch "$@"
}}

# open file manager in current folder 
cmd open-file-manager-window ${{
    if [[ "$(uname)" = "Darwin" ]]; then
        #open "$PWD"
        open -R "$f"
    fi
}}

# copy dirname, path, basename, ... (use xclip)
cmd copy-path ${{
    #printf '%s' "$fx" | xclip -i -selection clipboard
    printf '%s' "$fx" | pbcopy 
}}

cmd copy-dirname $dirname -- "$f" | head -c-1 | xclip -i -selection clipboard
cmd copy-basename $basename -a -- $fx | head -c-1 | xclip -i -selection clipboard
cmd copy-basename-without-extension &basename -a -- $fx | rev | cut -d. -f2- | rev | head -c-1 | xclip -i -selection clipboard


# show path on window title
cmd on-cd &{{
    # '&' commands run silently in background (which is what we want here),
    # but are not connected to stdout.
    # To make sure our escape sequence still reaches stdout we pipe it to /dev/tty
    printf "\033]0; $PWD\007" > /dev/tty
}}


# batch rename
cmd batch-rename ${{
    #vimv "$fx"
     if [ -z "$fs" ]; then
        vimv "$f"
    else
        IFS="`printf '\n\t'`"; vimv $fs 
    fi

}}


# === Run commands at startup ====
on-cd
